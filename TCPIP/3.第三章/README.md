## 问题

1. IP地址族IPv4和IPv6有何区别？在何种背景下诞生了IPv6？
  * 46页
2. 通过IPv4网络ID、主机ID及路由器的关系说明向公司局域网中的计算机传输数据的过程。
  * 47页
3. 套接字地址分为IP地址和端口号。为什么需要IP地址和端口号？或者说，通过IP可以区分哪些对象？通过端口号可以区分哪些对象？
  * 下面已解释
4. 请说明IP地址的分类方法，并据此说出下面这些IP地址的分类
  * 214.121.212.102 => 1101 ....(二进制) 不属于任何一种
  * 120.101.122.89  => 0111 1000(二进制) A类 第一个二进制位是0
  * 129.78.102.211  => 1000 0001(二进制) B类 前两位二进制是10
5. 计算机通过路由器或交换机连接到互联网。请说出路由器和交换机的作用。
  * 路由器是一种网络设备，用于**在不同的网络之间进行数据传输和转发**。它可以连接多个局域网（LAN）或广域网（WAN），并根据目标地址将数据包从一个网络转发到另一个网络。
  * 路由器工作在网络层（OSI模型的第三层），它能够识别目标地址，并根据路由表来确定最佳的数据传输路径。路由器根据目标IP地址对数据包进行路由，因此它能够实现不同网络之间的互联互通。
  * 路由器还具有网络地址转换（NAT）功能，可以将内部网络中的私有IP地址映射到公共IP地址，以实现内部网络与外部互联网的通信。
  * 交换机是一种网络设备，用于**在局域网内部进行数据交换和转发**。它可以连接多台计算机或其他网络设备，并在它们之间传输数据包。
  * 交换机工作在数据链路层（OSI模型的第二层），它能够识别目标MAC地址，并根据MAC地址表将数据包从一个端口转发到另一个端口，从而实现局域网内部的通信。
  * 交换机通常用于内部网络中，用于构建局域网或企业内部网络。它能够提供高速的数据传输和低延迟的网络连接，适用于连接多台计算机或其他网络设备。
6. 什么是知名端口？其范围是多少？知名端口中具有代表性的HTTP和FTP端口号各是多少？
  * 49页
  * HTTP 端口号为80
  * FTP 端口号为21
7. 向套接字分配地址的bind函数原型如下：
  `int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrleng);`
  而调用时则用
  `bind(serv_sock, (struct sockaddr*) &serv_addr, sizeof(serv_addr));`
  此处 serv_addr 和 sockaddr_in 结构体变量。与函数原型不同，传入的是sockaddr_in结构体变量，请说明原因。
  * 这涉及到C语言中的结构体类型兼容性和强制类型转换的概念。
  * 在C语言中，结构体类型的第一个成员是存储在内存中的起始位置，因此如果一个结构体的成员顺序与另一个结构体的成员顺序相同，并且相同位置的成员具有相同的数据类型，则可以对这两个结构体进行强制类型转换，而不会丢失数据。
  * 在这种情况下，sockaddr_in 结构体是 sockaddr 结构体的一个扩展，它在后面添加了一些额外的成员，用于存储 IP 地址和端口号等信息。因此，虽然 bind 函数的原型接受 struct sockaddr* 类型的参数，但是实际上可以传入指向 sockaddr_in 结构体的指针，因为它们的**内存布局是兼容**的。
  * 这种做法的原因在于历史和兼容性。早期的套接字编程接口使用的是通用的 sockaddr 结构体来表示套接字地址，后来为了方便使用，引入了 sockaddr_in 结构体，它专门用于表示 IPv4 地址。为了保持与旧版本的代码的兼容性，套接字函数的参数仍然是 struct sockaddr* 类型，但是可以传入 sockaddr_in 结构体的指针。
8. 请解释大端序、小端序、网络字节序、并说明为何需要网络字节序。
  * 53页
9. 大端序的计算机希望把4字节整数型数据12传递到小端序计算机。请说出数据传输过程中发生的字节序变换过程。
  * 传输方（大端字节序计算机）表示的数据为：0x00 0x00 0x00 0x0C。
  * 在传输过程中，不进行字节序转换，直接将数据按照大端字节序（网络字节序）传输。
  * 接收方（小端字节序计算机）接收到数据后，按照小端字节序的方式解释字节，即低位字节在前，高位字节在后。因此，接收方解释的数据为12（0x0C），即正确的结果。
10. 怎么表示回送地址？其含义是什么？如果向回送地址传递数据会发生什么情况？
  * 回送地址是网络中的一个特殊地址，用于在本地主机上进行回送（Loopback）。在IPv4中，回送地址是 127.0.0.1，在IPv6中，回送地址是 ::1。
  * 回送地址的含义是将数据发送回到发送方所在的主机上，而不是通过网络传输到其他主机。当数据被发送到回送地址时，操作系统会将数据发送到本地网络接口上，然后立即返回给发送方，而不会通过网络传输到其他主机。这使得应用程序能够在不连接到外部网络的情况下进行自我测试和调试。
  * 如果向回送地址传递数据，以下情况会发生：
    1. 数据将被发送到本地主机的网络接口。
    2. 操作系统会立即将数据返回给发送方。
    3. 数据不会通过网络传输到其他主机，而是保留在本地主机上。
    4. 应用程序可以在本地主机上接收和处理这些数据，进行自我测试和调试。

## 网络协议 (Internet Protocal) 

- **IP(简写)**是为收发网络数据而分配给计算机的值。
- **端口号**并非赋予计算机的值，而是同一操作系统内为区分程序中创建的套接字而分配给套接字的序号。

### 网络地址 (Internet Address) 46页

为使计算机连接到网络并收发数据，必需向其分配IP地址。IP地址分为两大类
* IPv4 (Internet Protocol version 4)   4字节地址族
* IPv6 (Internet Protocol version 6)   16字节地址族

IPv4标准4字节地址 =>  网络地址（网络ID） + 主机地址（主机ID）

网络地址（网络ID）是为了区分网络而设置的一部分IP地址。

IPv4与IPv6的差别主要是表示IP地址所用的字节数
IPv4标准的4字节IP地址分为网络地址和主机（指计算机）地址，且分为A、B、C、D、E等类型。

* A类地址：0开头
* B类地址：10开头
* C类地址：110开头
* D类地址：1110开头
* E类地址：1111开头

## 用于区分套接字的端口号 48页

## 地址信息的表示 50页

* 表示IPv4地址的结构体

```c
struct sockaddr_in {
  sa_family_t     sin_family; // 地址族(Address Family)
  uint16_t        sin_port;   // 16位 TCP/UDP 端口号
  struct in_addr  sin_addr;   // 32位 IP地址
  char            sin_zero[8];// 不使用
}
struct in_addr {
  In_addr_t       s_addr;     // 32位IPv4地址
}
```

uint16_t、int_addr_t等类型可以参考POSIX（Portable Operating System Interface，可移植操作系统接口）。POSIX是为UNIX系列操作系统设立的标准，它定义了一些其他数据类型。详情50页

## 网络字节序与地址变换

不同CPU中，4字节整数型值1在内存空间的保存方式是不同的。4字节整数型值1可用2进制表示如下：

00000000 00000000 00000000 00000001

有些CPU以这种顺序保存到内存，另外一些CPU则以倒序保存

00000001 00000000 00000000 00000000

若不考虑这些就收发数据则会发生问题，因为保存顺序的不同意味着对接收数据的解析顺序也不同

### 字节序 (order) 与网络字节序 53页

CPU向内存保存数据的方式有2种，这意味着CPU解析数据的方式也分为2种

* 大端序 (Big Endian): 高位字节存放到低位地址
* 小端序 (Little Endian): 高位字节存放到高位地址

注意：**字节**从左到右，是从高位到低位，而**地址**从左到右，是从低位到高位

* 例如，十六进制数 0x12345678 在大端字节序下的存储顺序是 12 34 56 78。

示例  12  34  56  78
字节 最高         最低
地址 最低         最高

* 例如，十六进制数 0x12345678 在小端字节序下的存储顺序是 78 56 34 12。

示例  78  56  34  12
字节 最高         最低
地址 最低         最高

### 字节序转换 54页

```c
unsigned short htons(unsigned short);
unsigned short ntohs(unsigned short);
unsigned long htonl(unsigned long);
unsigned long ntohl(unsigned long);
```

### 网络地址的初始化与分配 56页

```c
/**
 * 将字符串信息转换为网络字节序的整数型
 * @return 成功返回32位大端序整数型值，失败返回 INADDR_NONE
 */
in_addr_t inet_addr(const char* message);
```

inet_aton函数与inet_addr函数在功能上完全相同，也将字符串形式IP地址转换为32位网络字节序整数并返回。
只不过该函数利用了in_addr结构体，且使用频率更高

```c
/**
 * @param string 含有需转换的IP地址信息的字符串地址值
 * @param addr 将保存转换结果的in_addr结构体变量的地址值
 * @return 成功返回 1（true），失败返回 0（false）
 */
int inet_aton(const char* string, struct in_addr* addr);
```

在实际编程中若要调用inet_addr函数，需将转换后的IP地址信息代入sockaddr_in结构体中声明的in_addr结构体变量。
而inet_aton函数则不需此过程。原因在于，若传递in_addr结构体变量地址值，函数会自动把结果填入该结构体变量。

重点：掌握函数的调用方法

```c
/**
 * 把网络字节序整数型IP地址转换成我们熟悉的字符串形式
 * @return 成功返回转换的字符串地址值，失败返回-1
 */
char * inet_ntoa(struct in_addr adr);
```

### 网络地址初始化

结合前面内容，现在介绍套接字创建过程中常见的网络地址信息初始化方法：

```c
struct sockaddr_in addr;
char * serv_ip = "211.217.168.13"; // 声明IP地址字符串
char * serv_port = "9190";         // 声明端口号字符串
memset(&addr, 0, sizeof(addr));    // 结构体变量 addr 的所有成员初始化为0
addr.sin_family = AF_INET;         // 指定地址族
addr.sin_addr.s_addr = inet_addr(serv_ip);// 基于字符串的IP地址初始化
addr.sin_port = htons(atoi(serv_port));   // 基于字符串的端口号初始化
```

上述代码中，memset函数将每个字节初始化为同一值；第一个参数为结构体变量addr的地址值，即初始化对象为addr；第二个参数为0，因此初始化为0；最后一个参数传入addr的长度，因此addr的所有字节均初始化为0.这么做是为了将sockaddr_in结构体的成员sin_zero初始化为0。
另外，最后一行代码调用的atoi函数把字符串类型的值转换为整数型。
总之，上述代码利用字符串格式的IP地址和端口号初始化了sockaddr_in结构体变量。

### 客户端地址信息初始化

### INADDR_ANY

用于自动获取运行服务器端的计算机IP地址

## 第一章 hello_server.c、hello_client.c 运行过程

第一章中执行以下命令以运行，相当于服务器端端 hello_server.c `./hserver 9190`

通过代码可知，向main函数传递的9190为端口号。通过此端口号创建服务器端套接字并运行程序，但未传递IP地址，因为可以通过INADDR_ANY指定IP地址。

执行下列命令以运行相当于客户端的 hello_client.c。与服务器端运行方式相比，最大的区别是传递了IP地址信息。 `./hclient 127.0.0.1 9190`

127.0.0.1 是回送地址，指的是计算机自身IP地址。

## 向套接字分配网络地址

接下来就把初始化的地址信息分配给套接字。bind函数负责这项操作

如果此函数调用成功，则将第二个参数指定的地址信息分配给第一个参数中的相应套接字

服务器常见套接字初始化过程：

```c
int serv_sock;
struct sockaddr_in serv_addr;
char * serv_port = "9190";

// 创建服务器端套接字
serv_sock = socket(PF_INET, SOCK_STREAM, 0);
// 地址信息初始化
memset(&serv_addr, 0, sizeof(serv_addr));
serv_addr.sin_family = AF_INET;
serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
serv_addr.sin_port = htons(atoi(serv_port));
// 分配地址信息
bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
// ...
```