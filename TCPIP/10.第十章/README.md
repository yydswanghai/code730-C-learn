## 问题

1. 下列关于进程的说法错误的是? C
  * a.从操作系统的角度上说，进程是程序运行的单位
  * b.进程根据创建方式建立父子关系
  * c.进程可以包含其他进程，即一个进程的内存空间可以包含其他进程
  * d.子进程可以创建其他子进程，而创建出来的子进程还可以创建其子进程，但所有这些进程只与一个父进程建立父子关系
  * (169页: 进程是独立的执行实体，每个进程都有自己独立的内存空间，不会直接包含其他进程。)
2. 调用fork函数将创建子进程，以下关于子进程的描述错误的是? C
  * a.父进程销毁时也会同时销毁子进程
  * b.子进程是复制父进程所有资源创建出的进程
  * c.父子进程共享全局变量
  * d.通过fork函数创建的子进程将执行从开始到fork函数调用为止的代码
  * (在fork之后，父子进程会共享全局变量的初始值，但是它们各自拥有自己的内存空间，修改其中一个进程中的全局变量不会影响另一个进程中的值。)
3. 创建子进程时将复制父进程的所有内容，此时的复制对象也包含套接字文件描述符。编写程序验证复制的文件描述符整数值是否与原文件描述符整数值相同
  * 运行test_fork
4. 请说明进程变成僵尸进程的过程及预防措施
  * 产生僵尸进程的原因 170页
  * 销毁僵尸进程 172页
5. 如果在未注册SIGINT信号的情况下输入Ctrl+C，将由操作系统默认的事件处理器终止程序。但如果直接注册Ctrl+C信号的处理器，则程序不会终止，而是调用程序员指定的事件处理器。编写注册处理函数的程序，完成如下功能：
  “输入Ctrl+C时，询问是否确定退出程序，输入Y则终止程序”
另外，编写程序使其每间隔1秒输出简单字符串，并适用于上述时间处理器注册代码
  * 运行test_sign

## 进程 (Process) 166页

* 并发服务器端端实现方法 166页
  * 多进程服务器：通过创建多个进程提供服务
  * 多路复用服务器：通过捆绑并统一管理I/O对象提供服务
  * 多线程服务器：通过生成与客户端等量的线程提供服务

```c
#include <unistd.h>
/**
 * fork函数创建进程
 * @return 成功返回进程ID，失败返回-1
 */
pid_t fork(void);
```

```c
#include <sys/wait.h>
/**
 * 销毁僵尸进程 172页
 * @return 成功返回终止的子进程ID，失败返回-1
 */
pid_t wait(int * statloc);
```

```c
#include <sys/wait.h>
/**
 * 销毁僵尸进程
 * @param pid 等待终止的目标子进程的ID，若传递-1，则与wait函数相同，可以等待任意子进程终止
 * @param statloc 与wait函数的statloc参数具有相同含义
 * @param options 传递头文件sys/wait.h中声明的常量WNOHANG，即使没有终止的子进程也不会进入阻塞状态，而是返回0并退出函数
 * @return 成功返回终止的子进程ID（或0），失败返回-1
 */
pid_t waitpid(pid_t pid, int * statloc, int options);
```

## 信号处理 175页

```c
#include <signal.h>
// 为了在产生信号时调用，返回之前注册的函数指针
void ( *signal(int signo, void (*func)(int)) )(int);
```

上述函数的返回值类型为函数指针
* 函数名：signal
* 参数：int signo, void (*func)(int)
* 返回类型：参数为int型，返回void型函数指针

理解：void (*func)(int)
* void：表示这个函数指针指向的函数不返回任何值。
* (*func)：表示 func 是一个指针，指向一个函数。
* (int)：表示这个函数接受一个整数类型的参数。

```c
#include <signal.h>
/**
 * @param signo 与signal函数相同，传递信号信息
 * @param act 对应于第一个参数的信号处理函数（信号处理器）信息
 * @param oldact 通过此参数获取之前注册的信号处理函数指针，若不需要则传递0
 * @return 成功返回0，失败返回-1
 */
int sigaction(int signo, const struct sigaction * act, struct sigaction * oldact);
```

