## 问题

1. 请说明标准I/O函数的2个优点。它为何拥有这2个优点？
   * 256页
2. 利用标准I/O函数传输数据时，下面的想法是错误的：
  “调用fputs函数传输数据时，调用后立即开始发送！”
  为何说上述想法是错误的？为了达到这种效果应添加哪些处理过程？
  * 调用fputs并不意味着数据会立即被发送到目标设备或网络上。实际上，标准I/O库使用缓冲区（buffer）来优化I/O操作，因此当你调用fputs时，数据首先被写入到一个内部缓冲区中，然后在适当的时候（例如当缓冲区满时，或者显式地调用fflush时）才会被刷新（flush）到实际的文件或设备上。

fflush: 显式地调用fflush来刷新缓冲区，确保数据被发送到目标设备

## 标准I/O 256页

```c
#include <stdio.h>
/**
 * 打开一个文件
 * @param filename 文件名
 * @param mode
 *        r 以只读方式打开文件。文件必须存在
 *        w 以只写方式打开文件。如果文件存在，则其内容会被清空；如果文件不存在，则创建该文件
 *        a 以追加方式打开文件。如果文件存在，数据会被追加到文件末尾；如果文件不存在，则创建该文件
 *        r+ 以读写方式打开文件。文件必须存在
 *        w+ 以读写方式打开文件。如果文件存在，则其内容会被清空；如果文件不存在，则创建该文件
 *        a+ 以读写方式打开文件。如果文件存在，数据会被追加到文件末尾；如果文件不存在，则创建该文件。注意，在追加模式下，写入操作总是在文件末尾进行
 * @return 成功时返回 FILE指针，失败时返回 NULL
 */
FILE *fopen(const char *filename, const char *mode);

/**
 * 检测文件是否已到达文件末尾
 * @param stream 是一个指向 FILE 对象的指针
 * @return 成功(到达文件末尾，或发生了读取错误)时返回 EOF通常是-1，失败(未到达文件末尾且没有发生错误)时返回 零
 * @example if(feof(fp)){ // 到达文件末尾的处理逻辑 }
 */
int feof(FILE *stream);

/**
 * 从指定的流中读取一行
 * @param str 指向一个字符数组的指针，该数组用于存储读取的数据
 * @param n 要读取的最大字符数（包括空字符 '\0'）
 * @param stream 指向 FILE 对象的指针，该对象标识要从中读取数据的输入流
 * @return 成功(读取一行)时返回 str的指针，失败(到达文件末尾或发生错误)时返回 NULL
 */
char *fgets(char *str, int n, FILE *stream);

/**
 * 将一个字符串写入到一个指定的文件流或输出流中
 * @param str 这是一个指向字符数组的指针，包含了要写入的以空字符终止的字符序列，即需要写入文件或流中的字符串。
 * @param stream 这是一个指向 FILE 对象的指针，标识了要被写入字符串的流。这可以是一个文件流，也可以是标准输出流（如 stdout）
 * @return 成功(写入字符串函数)时返回 一个非负值，失败时返回 EOF（通常为-1）
 */
int fputs(const char *str, FILE *stream);

/**
 * 文件描述符转换为FILE指针
 * @param fildes 需要转换的文件描述符
 * @param mode 将要创建的 FILE结构体指针的模式信息
 * @return 成功时返回 转换的FILE结构体指针，失败时返回 NULL
 */
FILE * fdopen(int fildes, const char * mode);

/**
 * FILE指针转换为文件描述符
 * @param stream
 * @return 成功时返回 转换后的文件描述符，失败时返回 -1
 */
int fileno(FILE * stream);
```
