## 问题

1. 什么是协议？在收发数据中定义协议有何意义？
  * 36页
2. 面向连接的TCP套接字传输特性有3点，请分别说明。
3. 面向消息的套接字的特性？
4. 何种类型的套接字不存在数据边界？这类套接字接收数据时需要注意什么？
5. tcp_server.c和tcp_client.c中需多次调用read函数读取服务器端调用1次write函数传递的字符串。更改程序，使服务器端多次调用（次数自拟）write函数传输数据，客户端调用1次read函数进行读取。为达到这一目的，客户端需延迟调用read函数，因为客户端要等待服务器端传输所有数据。Windows和Linux都通过下列代码延迟read或recv函数的调用。
```c
for(i=0; i<3000; i++){
  printf("Wait time %d \n", i);
}
```
让CPU执行多余任务以延迟代码运行的方式称为 "Busy Waiting"。使用得当即可推迟函数调用。

### 协议族 (domain) 37页

套接字通信中的协议也具有一些分类。通过socket函数的第一个参数传递套接字中使用的协议分类信息。此**协议分类信息**称为协议族

* PF_INET     IPv4互联网协议族
* PF_INET6    IPv6互联网协议族
* PF_LOCAL    本地通信的UNIX协议族
* PF_PACKET   底层套接字的协议族
* PF_IPX      IPX Novell协议族

### 套接字类型 (type) 38页

是指套接字的**数据传输方式**，通过socket函数的第二个参数传递，只有这样才能决定创建的套接字的数据传输方式。这种说法可能会使人感到疑惑。已通过第一个参数传递了协议族信息，还要决定数据传输方式？问题就在于，决定了协议族并不能同时决定数据传输方式，换言之，socket函数第一个参数PF_INET协议族中也存在多种数据传输方式。

1. SOCK_STREAM (面向连接的套接字)

特征：可以想像2位工人通过一条传送带传递物品

* 传输过程中数据不会消失
  * 38页
  * 缓冲细节——101页
* 按序传输数据
* 传输的数据不存在数据边界

2. SOCK_DGRAM (面向消息的套接字)

特征：可以比喻成高速移动的摩托车快递。

* 强调快速传输而非传输顺序
* 传输的数据可能丢失也可能损毁
* 传输的数据有数据边界 (接收数据和传输数据的次数必须相同)
* 限制每次传输的数据大小

### 协议的最终选择 (protocol) 40页

socket函数的第三个参数，该参数决定最终采用的协议。你是否觉得困惑？
前面已经通过socket函数的前两个参数传递了协议族信息和数据传输方式，这些信息不足以决定采用的协议吗？为什么还需要传递第三个参数？

正如各位所想，传递前面两个参数即可创建所需套接字。所以大部分情况下可以向第三个参数传递0，除非遇到以下情况：

* 同一协议族中存在多个数据传输方式相同的协议。数据传输方式相同，但协议不同。此时需要指定具体的协议信息
  * 例如：创建"IPv4协议族中面向连接的套接字"。IPv4与网络地址系统相关，关于这一点将给出单独说明，参数 PF_INET 指IPv4网络协议族， SOCK_STREAM 是面向连接的数据传输。满足这两点条件的协议只有 IPPROTO_TCP ，因此可以如下调用socket函数创建套接字，这种套接字成为TCP套接字。
  * `int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);`
  * 例如：创建"IPv4协议族中面向消息的套接字"。SOCK_DGRAM 指的是面向消息的数据传输方式，满足上述条件的协议只有 IPPROTO_UDP 。因此，可以如下调用socket函数创建套接字，这种套接字称为UDP套接字
  * `int udp_socket = socket(PF_INET, 。SOCK_DGRAM, IPPROTO_UDP);`
