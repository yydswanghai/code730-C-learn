## 运算符 &

```c
int i;
scanf("%d", &i);
printf("%x", &i);
printf("%p", &i);
```

* 获得变量的地址，它的操作数必须是变量
* 地址的大小是否与int相同取决于编译器
* &不能取的地址
  * 不能对没有地址的东西取地址
    * &(a+b)?
    * &(a++)?
    * &(++a)?
* 试试这些&
  * 变量的地址
  * 相邻的变量的地址
  * &的结果的sizeof
  * 数组的地址
  * 数组单元的地址
  * 相邻的数组单元的地址

## scanf

* 如果能够将取得的变量的地址传递给一个函数？能否通过这个地址在那个函数内访问这个变量？
* scanf()的原型应该是怎样的？我们需要一个参数能保存别打变量的地址，如果表达能够保存地址的变量？

## 指针

* 就是保存地址的变量

```c
int i;
int* p = &i;// point 指针，变量p存放的是变量i的地址
int* p,q;// 细节：*号既可以靠近int也可以远离int，*号加给了p，而不是int，*p 是一个 int类型
int *p,q;// p和q都是指针
```

## 指针变量

* 变量的值是内存的地址
  * 普通变量的值是**实际的值**
  * 指针变量的值是**具有实际值的变量的地址**

## 作为参数的指针

```c
void f(int *p);

int i=0; 
f(&i);
```

* 在被调用的时候得到了某个变量的地址
* 在函数里面可以通过这个指针访问外面的这个i

## 访问那个地址上的变量*

* `*`是一个单目运算符，用来访问指针的值所表示的地址上的变量
* 可以做右值也可以做左值

```c
int k = *p;
*p = k + 1;
```

## 传入地址

* 为什么 `int i; scanf("%d", i);` 编译没有报错？
  * scanf 以为你传进去的是i的地址，编译不一定会报错，但是运行会出错。

## 指针应用场景

* 交换两个变量的值
* 函数返回多个值，某些值就只能通过指针返回
  * 传入的参数实际上是需要保存带回的结果的变量
* 函数返回运算的状态，结果通过指针返回
  * -1或0（在文件操作会看到大量的例子）
* 但是当任何数值都是有效的可能结果时，就是分开返回了
  * 后续的语言（C++、Java）采用了异常机制来解决这个问题

## 指针最常见的错误

* 定义了指针变量，还没有指向任何变量，就开始使用指针

## 传入函数的数组成了什么？

* 函数参数表中的数组实际上是指针
  * `sizeof(a) == sizeof(int*)`
  * 但是可以用数组的运算符[]进行运算
* 以下四种函数原型是等价的：

```c
int sum(int *ar, int n);
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);
```

## 数组变量是特殊的指针

```c
int a[10];
int *p = a;// 无需用&取地址
a = &a[0];// 需要用&取地址

p[0]
a[0]
```

* 数组变量本身表达地址，所以无需用&取地址
* 但是数组的单元表达的是变量，需要用&取地址
* `[]`运算符可以对数组做，也可以对指针做：
* 数组变量是const的指针，所以不能被赋值

## 指针是const

* 表示一旦得到了某个变量的地址，不能再指向其他变量

```c
int * const q = &i;// q是const
*q = 26;// OK
q++;// ERROR
```

## 所指是const

* 表示不能通过这个指针去修改那个变量（并不能使得那个变量成为const）

```c
const int *p = &i;
*p = 26;// ERROR
i = 26;// OK
p = &i;// OK
```

三种const，要么是指针不可被修改，要么是通过指针不可以被修改

```c
int i;
const int * p1 = &i;// *p1 通过指针不可以被修改
int const * p2 = &i;// *p2 通过指针不可以被修改
int * const p3 = &i;// p3  指针不可被修改
```

## 转换

* 总是可以把一个非const的值转换成const的

```c
void f(const int* x);// 传入一个const结构的指针，防止对传入的x进行修改
int a = 15;
f(&a);// ok
const int b = a;

f(&b);// ok
b = a +1;// Error
```

## const数组

```c
const int a[] = {1,2,3,4,5};
```

* 数组变量已经是const的指针了，这里的const表明数组的每个单元都是`const int`
* 所以必须通过初始化进行赋值

## 保护数组值

* 因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值
* 为了保护数组不被函数破坏，可以设置参数为const

```c
int sum(const int a[], int length);
```

## 1+1=2?

* 给一个指针加+1表示要让指针指向下一个变量

```c
int a[10];
int *p = a;
// *(p+1) --> a[1]
```

* 如果指针不是指向一片连续分配到空间，如数组，则这种运算没有意义

## 指针运算

* 这些算术运算可以对指针做：
  * 给指针加、减一个整数(+, +=, =, -=)
  * 递增递减(++/--)
  * 两个指针相减

## *p++

* 取出p所指的那个数据来，完事之后顺便把p移到下一个位置去
* *的优先级虽然高，但是没有++高
* 常用于数组类的连续空间操作
* 在某些CPU上，这可以直接被翻译成一条汇编指令

## 指针比较

* <,<=,==,>,>=,!= 都可以对指针做
* 比较它们在内存中的地址
* 数组中的单元的地址肯定是线性递增的

## 0地址

* 当然你的内存中有0地址，但是0地址通常是个不能随便碰的地址
* 所以你的指针不应该具有0值
* 因此可以用0地址来表示特殊的事情
  * 返回的指针是无效的
  * 指针没有被真正初始化
* NULL是一个预定定义的符号，表示0地址
  * 有的编译器不愿意你用0来表示0地址

## 指针的类型

* 无论指向什么类型，所有的指针的大小都是一样的，因为都是地址
* 但是指向不同类型的指针是不能直接互相赋值的
* 这是为了避免用错指针

* void* 表示不知道指向什么东西的指针
  * 计算时与char* 相同（但不相通）
* 指针也可以转换类型
  * int *p = &i; void*q = (void*)p;
* 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看它所指的变量
  * 我不再当你是int拉，我认为你就是个void。

## 用指针来做什么

* 需要传入较大的数据时用作参数
* 传入数组后对数组做操作
* 函数返回不止一个结果
  * 需要用函数来修改不止一个变量
* 动态申请的内存