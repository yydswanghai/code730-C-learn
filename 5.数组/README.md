## 定义数组

* <类型>变量名称[元素数量]
  * int grades[100];
  * double weight[20];
* 元素数量必须是整数
  * C99之前，元素数量必须是编译时刻确定的字面量

## 数组

* 是一种容器（放东西的东西），特点是：
  * 其中所有的元素具有相同的数据类型
  * 一旦创建，不能改变大小
  * 数组中的元素在内存中是连续依次排列的

* 例如：int a[10];
* 一个int的数组
* 10个单元：a[0], a[1], ... ,a[9]
![](./img5.png)
* 每个单元都是一个int类型的变量
* 可以出现在赋值的左边或右边
  * a[2] = a[1] + 6; 将a[1]的值读出来加上6，写入到a[2]
  * 在赋值左边的叫做左值

## 数组的单元

* 数组的每个单元就是数组类型的一个变量
* 使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数：

数组下标从0开始，是从C语言开始的，原因是为了简化编译器

## 有效的下标范围

* 编译器和运行环境都不会检查数组下标是否越界，无论是对数组单元做读还是做写
* 一旦程序运行，越界的数组访问可能造成问题，导致程序崩溃
  * segmentation fault
* 但是也可能运气好，没造成严重的后果
* 所以这是程序员的责任来保证程序只使用有效的下标值：[0, 数组的大小-1]

* int a[0];
  * 可以存在，但是无用

## 数组的集成初始化

* 用[n]在初始化数据中给出定位
* 没有定位的数据接在前面的位置后面
* 其他位置的值补零
* 也可以不给出数组大小，让编译器算
* 特别适合初始数据稀疏的数组

```c
int a[] = {2,4,6,7,1,3,5,9,11,13,23,14,23};
int a[10] = {0}; // 等同于初始化 0 0 0 0 0 0 0 0 0 0
int a[10] = { [0] = 2, [2] = 3, 6 }; // 等同于初始化 2 0 3 6 0 0 0 0 0 0 
```

## 数组的大小

* sizeof给出整个数组所占据的内容的大小，单位是字节

```c
int a[] = { 2,4,6,7,1,3,5,9,11,13,23,14,23 };

printf("a的大小%lu, a[0]的大小%lu, a一共有%lu个元素\n", sizeof(a), sizeof(a[0]), sizeof(a)/sizeof(a[0]));
```

## 数组的赋值

```c
int a[] = { 2,4,6,7,1,3,5,9,11,13,23,14,23 };
// int b[] = a;// 不能这样赋值，必须采用遍历
```

## 遍历数组

* 通常都是使用for循环，让循环变量i从0到<数组的长度，这样循环体内最大的i正好是数组最大的有效下标
* 常见错误是：
  * 循环结束的条件是<=数组长度，或：
  * 离开循环后，继续用i的值来做数组元素的下标！

* 数组作为函数的参数时：
  * 不能在[]中给出数组的大小
  * 不能再利用sizeof来计算数组的元素个数！

## Unix系统使用C小技巧

如果你想知道比如sqrt函数怎么用？
可以在shell里输入命令：`man sqrt`

## 二维数组

* int a[3][5]
* 通常理解为a是一个3行5列的矩阵
* a[i][j]是一个int，表示第i行第j列上的单元

```c
a[0][0] a[0][1] a[0][2] a[0][3] a[0][4]
a[1][0] a[1][1] a[1][2] a[1][3] a[1][4]
a[2][0] a[2][1] a[2][2] a[2][3] a[2][4]
```

## 二维数组的初始化

```c
int a[][5] = {
  {0,1,2,3,4},
  {2,3,4,5,6},
}
```

* 列数是必须给出的，行数可以由编译器来数
* 每行一个{}，逗号分隔
* 最后的逗号可以存在，有古老的传统
* 如果省略，表示补零
* 也可以用定位 (C99 ONLY)

